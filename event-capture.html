<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Capture</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f0f2f5;
      color: #1a1a2e;
      min-height: 100vh;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 24px;
      font-size: 24px;
      color: #1a1a2e;
    }
    /* Tabs */
    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #4361ee;
    }
    .tab {
      flex: 1;
      padding: 12px 16px;
      text-align: center;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: #fff;
      color: #4361ee;
      border: none;
      transition: background 0.2s, color 0.2s;
    }
    .tab.active {
      background: #4361ee;
      color: #fff;
    }
    .tab:hover:not(.active) {
      background: #eef0ff;
    }
    /* Panels */
    .panel { display: none; }
    .panel.active { display: block; }
    /* Card */
    .card {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }
    /* Upload area */
    .upload-area {
      border: 2px dashed #c5cae9;
      border-radius: 12px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
      position: relative;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #4361ee;
      background: #f5f7ff;
    }
    .upload-area svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      color: #9fa8da;
    }
    .upload-area p {
      color: #666;
      font-size: 14px;
      margin-bottom: 8px;
    }
    .upload-area .hint {
      font-size: 12px;
      color: #999;
    }
    .upload-area input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }
    /* Image preview */
    .image-preview {
      display: none;
      margin-top: 12px;
      text-align: center;
    }
    .image-preview img {
      max-width: 100%;
      max-height: 300px;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .image-preview .remove-btn {
      display: inline-block;
      margin-top: 8px;
      font-size: 13px;
      color: #e53935;
      cursor: pointer;
      background: none;
      border: none;
    }
    /* Text area */
    .email-textarea {
      width: 100%;
      min-height: 180px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      outline: none;
    }
    .email-textarea:focus {
      border-color: #4361ee;
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }
    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: background 0.2s, transform 0.1s;
    }
    .btn:active { transform: scale(0.98); }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .btn-primary {
      background: #4361ee;
      color: #fff;
      width: 100%;
      justify-content: center;
    }
    .btn-primary:hover:not(:disabled) { background: #3451d1; }
    .btn-google {
      background: #fff;
      color: #333;
      border: 2px solid #ddd;
      width: 100%;
      justify-content: center;
    }
    .btn-google:hover:not(:disabled) {
      border-color: #4285f4;
      background: #f8f9ff;
    }
    .btn-success {
      background: #22c55e;
      color: #fff;
      width: 100%;
      justify-content: center;
    }
    .btn-success:hover:not(:disabled) { background: #1db954; }
    /* Progress bar */
    .progress-container {
      display: none;
      margin-top: 12px;
    }
    .progress-bar-bg {
      height: 8px;
      background: #e8eaf6;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: #4361ee;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s;
    }
    .progress-text {
      font-size: 13px;
      color: #666;
      margin-top: 6px;
      text-align: center;
    }
    /* Form */
    .form-section {
      display: none;
    }
    .form-section.visible {
      display: block;
    }
    .form-section h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: #333;
    }
    .form-group {
      margin-bottom: 14px;
    }
    .form-group label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: #555;
      margin-bottom: 4px;
    }
    .form-group input, .form-group textarea {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      outline: none;
    }
    .form-group input:focus, .form-group textarea:focus {
      border-color: #4361ee;
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
    }
    .form-group textarea {
      min-height: 60px;
      resize: vertical;
    }
    .form-row {
      display: flex;
      gap: 12px;
    }
    .form-row .form-group { flex: 1; }
    /* Status messages */
    .status-msg {
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 12px;
      display: none;
    }
    .status-msg.success {
      display: block;
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    }
    .status-msg.error {
      display: block;
      background: #fef2f2;
      color: #991b1b;
      border: 1px solid #fecaca;
    }
    .status-msg a {
      color: inherit;
      font-weight: 600;
    }
    /* Auth status */
    .auth-status {
      text-align: center;
      padding: 8px;
      font-size: 13px;
      color: #666;
      margin-bottom: 8px;
    }
    .auth-status.connected {
      color: #22c55e;
      font-weight: 600;
    }
    /* Raw text toggle */
    .raw-text-toggle {
      font-size: 13px;
      color: #4361ee;
      cursor: pointer;
      background: none;
      border: none;
      margin-top: 8px;
    }
    .raw-text-box {
      display: none;
      margin-top: 8px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 12px;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 200px;
      overflow-y: auto;
      color: #555;
    }
    .day-chips {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .day-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      background: #f0f2f5;
      border: 1px solid #ddd;
      transition: background 0.15s, border-color 0.15s;
    }
    .day-chip:has(input:checked) {
      background: #4361ee;
      color: #fff;
      border-color: #4361ee;
    }
    .day-chip input { display: none; }
    .back-link {
      display: inline-block;
      margin-bottom: 16px;
      color: #4361ee;
      text-decoration: none;
      font-size: 14px;
    }
    .back-link:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div class="container">
    <a href="/" class="back-link">&larr; Back to Recipes</a>
    <h1>Event Capture</h1>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" data-tab="flyer">Scan Flyer</button>
      <button class="tab" data-tab="email">Paste Email</button>
    </div>

    <!-- Scan Flyer Panel -->
    <div class="panel active" id="panel-flyer">
      <div class="card">
        <div class="upload-area" id="upload-area">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.774 48.774 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" />
          </svg>
          <p>Take a photo or upload a flyer image</p>
          <div class="hint">Tap to use camera on mobile, or drag & drop an image</div>
          <input type="file" id="file-input" accept="image/*" capture="environment">
        </div>
        <div class="image-preview" id="image-preview">
          <img id="preview-img" alt="Flyer preview">
          <br>
          <button class="remove-btn" id="remove-image">Remove image</button>
        </div>
        <div class="progress-container" id="ocr-progress">
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="progress-fill"></div>
          </div>
          <div class="progress-text" id="progress-text">Initializing OCR...</div>
        </div>
        <br>
        <button class="btn btn-primary" id="scan-btn" disabled>Scan Flyer</button>
      </div>
    </div>

    <!-- Paste Email Panel -->
    <div class="panel" id="panel-email">
      <div class="card">
        <textarea class="email-textarea" id="email-text" placeholder="Paste the email or event text here...&#10;&#10;Example:&#10;Subject: Annual Community BBQ&#10;Date: March 15, 2026&#10;Time: 2:00 PM - 6:00 PM&#10;Location: Riverside Park, 456 River Rd&#10;Join us for food, games, and fun!"></textarea>
        <br><br>
        <button class="btn btn-primary" id="parse-btn">Extract Event Details</button>
      </div>
    </div>

    <!-- Extracted Event Details Form -->
    <div class="form-section" id="event-form">
      <div class="card">
        <h2>Event Details</h2>
        <div id="form-status"></div>
        <div class="form-group">
          <label for="event-title">Title</label>
          <input type="text" id="event-title" placeholder="Event name">
        </div>
        <div class="form-group">
          <label for="event-date">Date</label>
          <input type="date" id="event-date">
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="event-start">Start Time</label>
            <input type="time" id="event-start">
          </div>
          <div class="form-group">
            <label for="event-end">End Time</label>
            <input type="time" id="event-end">
          </div>
        </div>
        <div class="form-group">
          <label for="event-location">Location</label>
          <input type="text" id="event-location" placeholder="Venue or address">
        </div>
        <div class="form-group">
          <label for="event-recurrence">Recurrence</label>
          <select id="event-recurrence">
            <option value="none">One-time event</option>
            <option value="DAILY">Daily</option>
            <option value="WEEKLY">Weekly</option>
          </select>
        </div>
        <div id="recurrence-options" style="display:none;">
          <div class="form-group">
            <label>Repeat on</label>
            <div class="day-chips" id="day-chips">
              <label class="day-chip"><input type="checkbox" value="MO"> Mon</label>
              <label class="day-chip"><input type="checkbox" value="TU"> Tue</label>
              <label class="day-chip"><input type="checkbox" value="WE"> Wed</label>
              <label class="day-chip"><input type="checkbox" value="TH"> Thu</label>
              <label class="day-chip"><input type="checkbox" value="FR"> Fri</label>
              <label class="day-chip"><input type="checkbox" value="SA"> Sat</label>
              <label class="day-chip"><input type="checkbox" value="SU"> Sun</label>
            </div>
          </div>
          <div class="form-group">
            <label for="event-end-date">Repeat until</label>
            <input type="date" id="event-end-date">
          </div>
        </div>
        <div class="form-group">
          <label for="event-desc">Notes / Description</label>
          <textarea id="event-desc" placeholder="Additional details..."></textarea>
        </div>

        <button class="raw-text-toggle" id="toggle-raw">Show raw extracted text</button>
        <div class="raw-text-box" id="raw-text-box"></div>

        <br>
        <div class="auth-status" id="auth-status">Checking Google Calendar connection...</div>
        <button class="btn btn-google" id="connect-btn">
          <svg width="18" height="18" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 01-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
          Connect Google Calendar
        </button>
        <br>
        <button class="btn btn-success" id="create-btn" disabled>Add to Google Calendar</button>
      </div>
    </div>
  </div>

  <!-- Tesseract.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // ============================================================
    // Event Text Parser
    // ============================================================
    const EventParser = (() => {
      const MONTH_NAMES = 'january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec';
      const MONTHS = {
        january: 0, february: 1, march: 2, april: 3, may: 4, june: 5,
        july: 6, august: 7, september: 8, october: 9, november: 10, december: 11,
        jan: 0, feb: 1, mar: 2, apr: 3, jun: 5, jul: 6, aug: 7, sep: 8, sept: 8, oct: 9, nov: 10, dec: 11
      };
      const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

      // --- OCR Text Cleanup ---
      function cleanOcrText(text) {
        return text.split('\n').map(line => {
          line = line.replace(/^[^a-zA-Z0-9]+/, '').replace(/[^a-zA-Z0-9.!?)]+$/, '');
          return line;
        }).filter(line => {
          if (!line || line.length < 2) return false;
          const alphaCount = (line.match(/[a-zA-Z0-9]/g) || []).length;
          return alphaCount / line.length > 0.4;
        }).join('\n');
      }

      // --- OCR Year Correction ---
      // OCR often mangles years: "202b" -> 2026, "Z0ZB" -> 2026, "2O26" -> 2026
      function fixOcrYear(yearStr) {
        if (!yearStr) return null;
        // Common OCR character substitutions for digits
        const fixes = { 'o': '0', 'O': '0', 'z': '2', 'Z': '2', 'b': '6', 'B': '6', 'l': '1', 'I': '1', 'S': '5', 's': '5', 'G': '6', 'g': '9', 'q': '9' };
        let fixed = '';
        for (const ch of yearStr) {
          fixed += fixes[ch] || ch;
        }
        const num = parseInt(fixed);
        if (num >= 2020 && num <= 2040) return num;
        return null;
      }

      // --- Date Extraction ---
      // Normalize a string for date extraction: strip degree symbols, fix OCR punctuation
      function prepForDateParse(str) {
        return str
          .replace(/[°º`]/g, '')           // Remove degree symbols OCR adds to numbers
          .replace(/[;]/g, ',')             // OCR semicolons -> commas
          .replace(/\s+/g, ' ');            // Normalize whitespace
      }

      function extractDateFromString(rawStr) {
        const str = prepForDateParse(rawStr);

        // "MARCH 7, 2026" / "MARCH, 7 2026" / "Feb 20th, 2026" / "MARCH 772026" (digits run together)
        // \b ensures we don't match "JUN" inside "JUNIOR" etc.
        const monthRe = new RegExp('\\b(' + MONTH_NAMES + ')\\b[,\\s]*(\\d+)(?:st|nd|rd|th)?[,\\s]*([\\w\\d]{4})?', 'i');
        const longDate = str.match(monthRe);
        if (longDate) {
          const month = MONTHS[longDate[1].toLowerCase()];
          const digitsPart = longDate[2]; // could be "7", "77", "772026", etc.
          let day, yearFromDigits = null;

          if (digitsPart.length <= 2) {
            // Normal: "7" or "20"
            day = parseInt(digitsPart);
          } else {
            // Digits run together: "772026" or "772025" -> split into day + year
            // Try 1-digit day first, then 2-digit
            let found = false;
            for (let split = 1; split <= Math.min(2, digitsPart.length - 3); split++) {
              const tryDay = parseInt(digitsPart.substring(0, split));
              const tryYearStr = digitsPart.substring(split);
              const tryYear = fixOcrYear(tryYearStr);
              if (tryDay >= 1 && tryDay <= 31 && tryYear) {
                day = tryDay;
                yearFromDigits = tryYear;
                found = true;
                break;
              }
            }
            if (!found) day = parseInt(digitsPart.substring(0, 2));
          }

          const yearStr = longDate[3] || null;
          const year = yearFromDigits || (yearStr ? (fixOcrYear(yearStr) || guessYear(month, day)) : guessYear(month, day));
          if (day >= 1 && day <= 31) return formatDate(year, month, day);
        }

        // "12/20/2026" or "12/20/26" or "12-20-2026"
        const numDate = str.match(/\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\b/);
        if (numDate) {
          let month = parseInt(numDate[1]) - 1;
          let day = parseInt(numDate[2]);
          let year = parseInt(numDate[3]);
          if (year < 100) year += 2000;
          return formatDate(year, month, day);
        }

        // ISO: 2026-02-20
        const isoMatch = str.match(/(\d{4})-(\d{2})-(\d{2})/);
        if (isoMatch) return `${isoMatch[1]}-${isoMatch[2]}-${isoMatch[3]}`;

        // Relative dates
        const relDay = str.match(/\b(this|next)\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\b/i);
        if (relDay) {
          const targetDay = DAYS.indexOf(relDay[2].toLowerCase());
          const today = new Date();
          let diff = targetDay - today.getDay();
          if (relDay[1].toLowerCase() === 'next') { diff = diff <= 0 ? diff + 14 : diff + 7; }
          else { if (diff <= 0) diff += 7; }
          const target = new Date(today);
          target.setDate(today.getDate() + diff);
          return formatDate(target.getFullYear(), target.getMonth(), target.getDate());
        }
        if (/\btomorrow\b/i.test(str)) {
          const d = new Date(); d.setDate(d.getDate() + 1);
          return formatDate(d.getFullYear(), d.getMonth(), d.getDate());
        }

        return null;
      }

      function parseDate(text) {
        const lines = text.split('\n');
        // Priority 1: WHEN: or Date: labeled lines
        for (const line of lines) {
          const m = line.match(/(?:date|when)\s*[:]\s*(.+)/i);
          if (m) { const d = extractDateFromString(m[1]); if (d) return d; }
        }
        // Priority 2: Any line in the text
        const d = extractDateFromString(text);
        return d || '';
      }

      function guessYear(month, day) {
        const now = new Date();
        const thisYear = now.getFullYear();
        const candidate = new Date(thisYear, month, day);
        if (candidate < new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)) return thisYear + 1;
        return thisYear;
      }

      function formatDate(year, month, day) {
        return `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      }

      // --- Time Extraction ---
      function normalizeTime(timeStr, referenceStr) {
        timeStr = timeStr.trim().toLowerCase().replace(/\./g, ':');
        let match = timeStr.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)?$/i);
        if (!match) return '';
        let hours = parseInt(match[1]);
        let minutes = match[2] ? parseInt(match[2]) : 0;
        let period = match[3]?.toLowerCase();
        if (hours > 23 || (period && hours > 12)) return '';
        if (!period && referenceStr) {
          const ref = referenceStr.match(/(am|pm)/i);
          if (ref) period = ref[1].toLowerCase();
        }
        if (period === 'pm' && hours < 12) hours += 12;
        if (period === 'am' && hours === 12) hours = 0;
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
      }

      // Find all HH:MM patterns in a string and return as array
      function findAllTimes(str) {
        const times = [];
        // Match "H:MM" or "HH:MM" optionally followed by am/pm
        const re = /(?<!\d)(\d{1,2}):(\d{2})\s*(am|pm)?/gi;
        let m;
        while ((m = re.exec(str)) !== null) {
          const h = parseInt(m[1]);
          // Skip if it looks like a year (e.g., matched inside "2025")
          if (m.index > 0 && /\d/.test(str[m.index - 1])) continue;
          if (h > 23) continue;
          times.push({ raw: m[0].trim(), hours: h, minutes: parseInt(m[2]), period: m[3] || null, index: m.index });
        }
        return times;
      }

      function extractTimesFromString(str) {
        // Strategy: find all HH:MM occurrences and pair them as start/end
        const times = findAllTimes(str);
        if (times.length >= 2) {
          // Use last period (am/pm) to infer earlier times
          const lastPeriod = times[times.length - 1].period;
          const refStr = lastPeriod ? lastPeriod : '';
          return {
            start: normalizeTime(times[0].raw, refStr),
            end: normalizeTime(times[1].raw, refStr)
          };
        }
        if (times.length === 1) {
          return { start: normalizeTime(times[0].raw), end: '' };
        }

        // Fallback: plain "7 PM" / "7pm" style (no colon)
        const plainRange = str.match(/(?<!\d)(\d{1,2})\s*(?:am|pm)?\s*[-–—to:;]+\s*(\d{1,2})\s*(am|pm)/i);
        if (plainRange) {
          return {
            start: normalizeTime(plainRange[1], plainRange[3]),
            end: normalizeTime(plainRange[2] + plainRange[3])
          };
        }
        const single = str.match(/(?<!\d)(\d{1,2}\s*(?:am|pm))/i);
        if (single) {
          return { start: normalizeTime(single[1]), end: '' };
        }
        return { start: '', end: '' };
      }

      function parseTime(text) {
        const lines = text.split('\n');

        // Priority 1: WHEN: or Time: labeled lines
        for (const line of lines) {
          const m = line.match(/(?:time|starts?|begins?|when)\s*[:]\s*(.+)/i);
          if (m) {
            const times = extractTimesFromString(m[1]);
            if (times.start) return times;
          }
        }

        // Priority 2: Find time patterns anywhere
        const times = extractTimesFromString(text);
        if (times.start) return times;

        return { start: '', end: '' };
      }

      // --- Location ---
      function parseLocation(text) {
        const lines = text.split('\n');
        for (const line of lines) {
          const m = line.match(/(?:location|where|venue|place|address)\s*[:\-;]\s*(.+)/i);
          if (m) return m[1].replace(/;/g, ',').replace(/[^a-zA-Z0-9.,\s]+$/, '').trim();
        }
        const addrMatch = text.match(/\b(\d{1,5}\s+[A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*\s+(?:St|Street|Ave|Avenue|Blvd|Boulevard|Rd|Road|Dr|Drive|Ln|Lane|Way|Ct|Court|Pl|Place|Pkwy|Parkway|Cir|Circle)\.?(?:\s*,?\s*[A-Za-z\s]+)?(?:\s*,?\s*[A-Z]{2}\s+\d{5})?)/);
        if (addrMatch) return addrMatch[1].trim();
        const atMatch = text.match(/\bat\s+(?:the\s+)?([A-Z][A-Za-z\s'&]+(?:Center|Hall|Park|Room|Building|Church|School|Library|Museum|Theater|Theatre|Arena|Stadium|Club|Hotel|Restaurant|Cafe|Bar|Lounge|Garden|Plaza|Square))/);
        if (atMatch) return atMatch[1].trim();
        return '';
      }

      // --- Title ---
      function isTitleCandidate(line) {
        if (line.length < 5 || line.length > 120) return false;
        // Must have at least 2 real words (3+ letters)
        const realWords = line.match(/[a-zA-Z]{3,}/g) || [];
        if (realWords.length < 2) return false;
        // Alpha ratio must be reasonable
        const alphaCount = (line.match(/[a-zA-Z]/g) || []).length;
        if (alphaCount / line.length < 0.5) return false;
        // Reject lines with too many single-char words
        const words = line.split(/\s+/);
        const singleCharWords = words.filter(w => w.length <= 1).length;
        if (words.length > 2 && singleCharWords / words.length >= 0.4) return false;
        return true;
      }

      function parseTitle(text) {
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);
        for (const line of lines) {
          const subj = line.match(/subject\s*[:]\s*(.+)/i);
          if (subj && isTitleCandidate(subj[1].trim())) return subj[1].trim();
        }
        for (const line of lines) {
          const label = line.match(/(?:event|title|what)\s*[:]\s*(.+)/i);
          if (label && isTitleCandidate(label[1].trim())) return label[1].trim();
        }
        const skipPattern = /(date|time|when|where|location|venue|place|from|to|subject|event|title|what|rsvp|contact|phone|email|tel|cost|sign\s*up)\s*:/i;
        for (const line of lines) {
          if (skipPattern.test(line)) continue;
          if (/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/.test(line)) continue;
          if (/^\d{1,2}:\d{2}\s*(am|pm)?$/i.test(line)) continue;
          if (isTitleCandidate(line)) return line;
        }
        return '';
      }

      // --- Recurrence Detection ---
      function parseRecurrence(text) {
        const DAY_PATTERN = '(?:sunday|monday|tuesday|wednesday|thursday|friday|saturday|sun|mon|tue|tues|wed|thu|thur|thurs|fri|sat)s?';
        const DAY_MAP = {
          sunday: 'SU', sun: 'SU', monday: 'MO', mon: 'MO',
          tuesday: 'TU', tue: 'TU', tues: 'TU', wednesday: 'WE', wed: 'WE',
          thursday: 'TH', thu: 'TH', thur: 'TH', thurs: 'TH',
          friday: 'FR', fri: 'FR', saturday: 'SA', sat: 'SA'
        };

        function parseDays(str) {
          const re = new RegExp(DAY_PATTERN, 'gi');
          const days = [];
          let m;
          while ((m = re.exec(str)) !== null) {
            const key = m[0].toLowerCase().replace(/s$/, '');
            if (DAY_MAP[key] && !days.includes(DAY_MAP[key])) days.push(DAY_MAP[key]);
          }
          return days;
        }

        const lines = text.split('\n').join(' ');
        const result = { isRecurring: false, frequency: '', days: [], endDate: '' };

        // "Every Saturday" / "every Tue and Thu" / "every Monday, Wednesday, Friday"
        const everyMatch = lines.match(new RegExp('every\\s+(' + DAY_PATTERN + '(?:\\s*[,&and/]+\\s*' + DAY_PATTERN + ')*)', 'i'));
        if (everyMatch) {
          result.isRecurring = true;
          result.frequency = 'WEEKLY';
          result.days = parseDays(everyMatch[1]);
        }

        // "Saturdays from March 1 to May 15" / "Tuesdays & Thursdays, 3/1 - 5/15"
        const daysWithRange = lines.match(new RegExp('(' + DAY_PATTERN + '(?:\\s*[,&and/]+\\s*' + DAY_PATTERN + ')*)\\s*[,.]?\\s*(?:from\\s+)?', 'i'));
        if (daysWithRange && !result.isRecurring) {
          const days = parseDays(daysWithRange[1]);
          if (days.length > 0) {
            result.isRecurring = true;
            result.frequency = 'WEEKLY';
            result.days = days;
          }
        }

        // "weekly" keyword
        if (!result.isRecurring && /\bweekly\b/i.test(lines)) {
          result.isRecurring = true;
          result.frequency = 'WEEKLY';
        }

        // "daily" keyword
        if (!result.isRecurring && /\bdaily\b/i.test(lines)) {
          result.isRecurring = true;
          result.frequency = 'DAILY';
        }

        // "X weeks" / "X sessions" -> hints at recurrence
        const weeksMatch = lines.match(/(\d+)\s*(?:weeks?|sessions?)\b/i);
        if (weeksMatch && !result.isRecurring) {
          result.isRecurring = true;
          result.frequency = 'WEEKLY';
          result.count = parseInt(weeksMatch[1]);
        }

        // Look for end date: "through May 15" / "until June 1" / "ends May 30" / "- May 15"
        if (result.isRecurring) {
          const endMatch = lines.match(/(?:through|until|thru|ends?|ending)\s+(.+?)(?:\.|,|$)/i);
          if (endMatch) {
            const d = extractDateFromString(endMatch[1]);
            if (d) result.endDate = d;
          }
          // Also look for "Month Day - Month Day" range where second date is end
          const rangeMonths = lines.match(new RegExp('\\b(' + MONTH_NAMES + ')\\b[\\s,]*(\\d{1,2})\\s*[-–—]\\s*(' + MONTH_NAMES + ')\\b[\\s,]*(\\d{1,2})', 'i'));
          if (rangeMonths && !result.endDate) {
            const endMonth = MONTHS[rangeMonths[3].toLowerCase()];
            const endDay = parseInt(rangeMonths[4]);
            if (endDay >= 1 && endDay <= 31) {
              result.endDate = formatDate(guessYear(endMonth, endDay), endMonth, endDay);
            }
          }
        }

        return result;
      }

      // --- Description ---
      // Clean a line for description: strip leading OCR noise like "oO ", "o ", etc.
      function cleanDescLine(line) {
        return line.replace(/^[oO0]{1,2}\s+/, '').replace(/\s+[rR][tT]\)?$/, '').trim();
      }

      // Check if a line contains real readable content (not OCR junk)
      function isReadableLine(line) {
        if (line.length < 8) return false;
        const words = line.split(/\s+/).filter(w => w.length > 0);
        if (words.length < 2) return false;
        // Count "real words" (3+ consecutive letters)
        const realWords = line.match(/[a-zA-Z]{3,}/g) || [];
        if (realWords.length < 2) return false;
        // Average word length must suggest real text
        const avgWordLen = words.reduce((s, w) => s + w.length, 0) / words.length;
        if (avgWordLen < 3) return false;
        // Reject lines where too many words are 1 char (OCR scatter)
        const singleCharWords = words.filter(w => w.length <= 1).length;
        if (words.length > 2 && singleCharWords / words.length >= 0.35) return false;
        // Alpha ratio - most of the line should be letters
        const alphaCount = (line.match(/[a-zA-Z]/g) || []).length;
        if (alphaCount / line.length < 0.6) return false;
        // Reject lines with abbreviation-slash patterns (like "D/B/J", "Br/ CGT")
        if (/\b[a-zA-Z]{1,3}\//.test(line)) return false;
        // Reject all-caps junk: require 2+ words with 5+ chars, or 3+ words with 4+ chars
        if (line === line.toUpperCase()) {
          const longWords = (line.match(/[A-Z]{5,}/g) || []).length;
          const medWords = (line.match(/[A-Z]{4,}/g) || []).length;
          if (longWords < 2 && medWords < 3) return false;
        }
        return true;
      }

      function parseDescription(text) {
        const lines = text.split('\n').map(l => l.trim()).filter(l => l);
        const title = parseTitle(text);
        const skipLabels = /(date|time|when|where|location|venue|place|subject|event|title|what|cost|sign\s*up)\s*:/i;
        const descLines = [];
        let foundTitle = false;
        for (let line of lines) {
          if (line === title && !foundTitle) { foundTitle = true; continue; }
          if (skipLabels.test(line)) continue;
          line = cleanDescLine(line);
          if (!isReadableLine(line)) continue;
          descLines.push(line);
        }
        return descLines.join('\n').trim().substring(0, 500);
      }

      return {
        parse(rawText) {
          const text = cleanOcrText(rawText);
          const date = parseDate(text);
          const { start, end } = parseTime(text);
          const location = parseLocation(text);
          const title = parseTitle(text);
          const description = parseDescription(text);
          const recurrence = parseRecurrence(text);
          return { title, date, startTime: start, endTime: end, location, description, recurrence };
        }
      };
    })();

    // ============================================================
    // UI Logic
    // ============================================================
    const $ = id => document.getElementById(id);

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
      });
    });

    // File upload / camera
    let selectedFile = null;
    const fileInput = $('file-input');
    const uploadArea = $('upload-area');
    const imagePreview = $('image-preview');
    const previewImg = $('preview-img');
    const scanBtn = $('scan-btn');

    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) handleFile(e.target.files[0]);
    });

    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
    uploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
    });

    function handleFile(file) {
      selectedFile = file;
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImg.src = e.target.result;
        imagePreview.style.display = 'block';
        uploadArea.style.display = 'none';
        scanBtn.disabled = false;
      };
      reader.readAsDataURL(file);
    }

    $('remove-image').addEventListener('click', () => {
      selectedFile = null;
      fileInput.value = '';
      imagePreview.style.display = 'none';
      uploadArea.style.display = 'block';
      scanBtn.disabled = true;
    });

    // Image preprocessing for better OCR
    function preprocessImage(imgSrc) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Scale up small images for better OCR (Tesseract works best at ~300 DPI)
          const scale = Math.max(1, Math.min(3, 2000 / Math.max(img.width, img.height)));
          canvas.width = img.width * scale;
          canvas.height = img.height * scale;
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

          // Convert to grayscale
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          const grayValues = new Uint8Array(canvas.width * canvas.height);
          for (let i = 0; i < data.length; i += 4) {
            grayValues[i / 4] = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
          }

          // Adaptive thresholding (works much better on flyers with colored backgrounds)
          const w = canvas.width, h = canvas.height;
          const blockSize = Math.max(15, Math.round(Math.min(w, h) / 30) | 1); // ensure odd
          const halfBlock = Math.floor(blockSize / 2);
          const C = 10; // threshold offset

          // Build integral image for fast local mean calculation
          const integral = new Float64Array((w + 1) * (h + 1));
          for (let y = 0; y < h; y++) {
            let rowSum = 0;
            for (let x = 0; x < w; x++) {
              rowSum += grayValues[y * w + x];
              integral[(y + 1) * (w + 1) + (x + 1)] = integral[y * (w + 1) + (x + 1)] + rowSum;
            }
          }

          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const x1 = Math.max(0, x - halfBlock), y1 = Math.max(0, y - halfBlock);
              const x2 = Math.min(w - 1, x + halfBlock), y2 = Math.min(h - 1, y + halfBlock);
              const area = (x2 - x1 + 1) * (y2 - y1 + 1);
              const sum = integral[(y2 + 1) * (w + 1) + (x2 + 1)]
                        - integral[y1 * (w + 1) + (x2 + 1)]
                        - integral[(y2 + 1) * (w + 1) + x1]
                        + integral[y1 * (w + 1) + x1];
              const localMean = sum / area;
              const idx = (y * w + x) * 4;
              const val = grayValues[y * w + x] > localMean - C ? 255 : 0;
              data[idx] = data[idx + 1] = data[idx + 2] = val;
            }
          }

          ctx.putImageData(imageData, 0, 0);
          resolve(canvas.toDataURL());
        };
        img.src = imgSrc;
      });
    }

    // OCR with Tesseract.js
    scanBtn.addEventListener('click', async () => {
      if (!selectedFile) return;
      scanBtn.disabled = true;
      const progressContainer = $('ocr-progress');
      const progressFill = $('progress-fill');
      const progressText = $('progress-text');
      progressContainer.style.display = 'block';

      try {
        // Preprocess image
        progressText.textContent = 'Preprocessing image...';
        const processed = await preprocessImage(previewImg.src);

        progressText.textContent = 'Starting OCR...';
        const result = await Tesseract.recognize(processed, 'eng', {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              const pct = Math.round(m.progress * 100);
              progressFill.style.width = pct + '%';
              progressText.textContent = `Recognizing text... ${pct}%`;
            } else if (m.status) {
              progressText.textContent = m.status + '...';
            }
          }
        });

        const ocrText = result.data.text;
        progressFill.style.width = '100%';
        progressText.textContent = 'Done!';

        fillFormFromText(ocrText);
      } catch (err) {
        progressText.textContent = 'OCR failed: ' + err.message;
      } finally {
        scanBtn.disabled = false;
      }
    });

    // Parse email text
    $('parse-btn').addEventListener('click', () => {
      const text = $('email-text').value.trim();
      if (!text) return;
      fillFormFromText(text);
    });

    function fillFormFromText(text) {
      const parsed = EventParser.parse(text);
      $('event-title').value = parsed.title;
      $('event-date').value = parsed.date;
      $('event-start').value = parsed.startTime;
      $('event-end').value = parsed.endTime;
      $('event-location').value = parsed.location;
      $('event-desc').value = parsed.description;

      // Recurrence
      const rec = parsed.recurrence;
      $('event-recurrence').value = rec.isRecurring ? rec.frequency : 'none';
      toggleRecurrenceOptions();
      // Set day checkboxes
      document.querySelectorAll('#day-chips input').forEach(cb => {
        cb.checked = rec.days && rec.days.includes(cb.value);
      });
      $('event-end-date').value = rec.endDate || '';

      // Show raw text
      $('raw-text-box').textContent = text;

      // Show form
      $('event-form').classList.add('visible');
      $('event-form').scrollIntoView({ behavior: 'smooth' });
    }

    // Toggle recurrence options visibility
    function toggleRecurrenceOptions() {
      const val = $('event-recurrence').value;
      $('recurrence-options').style.display = val !== 'none' ? 'block' : 'none';
    }
    $('event-recurrence').addEventListener('change', toggleRecurrenceOptions);

    // Toggle raw text
    $('toggle-raw').addEventListener('click', () => {
      const box = $('raw-text-box');
      const btn = $('toggle-raw');
      if (box.style.display === 'block') {
        box.style.display = 'none';
        btn.textContent = 'Show raw extracted text';
      } else {
        box.style.display = 'block';
        btn.textContent = 'Hide raw extracted text';
      }
    });

    // ============================================================
    // Google Calendar Integration
    // ============================================================
    let isCalendarConnected = false;

    async function checkAuthStatus() {
      try {
        const res = await fetch('/api/events/auth/status');
        const data = await res.json();
        isCalendarConnected = data.connected;
        updateAuthUI();
      } catch {
        $('auth-status').textContent = '';
      }
    }

    function updateAuthUI() {
      const status = $('auth-status');
      const connectBtn = $('connect-btn');
      const createBtn = $('create-btn');

      if (isCalendarConnected) {
        status.textContent = 'Connected to Google Calendar';
        status.className = 'auth-status connected';
        connectBtn.style.display = 'none';
        createBtn.disabled = false;
      } else {
        status.textContent = 'Not connected to Google Calendar';
        status.className = 'auth-status';
        connectBtn.style.display = '';
        createBtn.disabled = true;
      }
    }

    // Listen for OAuth popup callback
    window.addEventListener('message', (e) => {
      if (e.data === 'calendar-connected') {
        isCalendarConnected = true;
        updateAuthUI();
      }
    });

    $('connect-btn').addEventListener('click', () => {
      // Open OAuth flow in popup
      const w = 500, h = 600;
      const left = (screen.width - w) / 2;
      const top = (screen.height - h) / 2;
      window.open('/api/events/auth', 'google-auth', `width=${w},height=${h},left=${left},top=${top}`);
    });

    $('create-btn').addEventListener('click', async () => {
      const title = $('event-title').value.trim();
      const date = $('event-date').value;
      const startTime = $('event-start').value;
      const endTime = $('event-end').value;
      const location = $('event-location').value.trim();
      const description = $('event-desc').value.trim();
      const recurrenceType = $('event-recurrence').value;
      const recurrenceDays = [...document.querySelectorAll('#day-chips input:checked')].map(cb => cb.value);
      const recurrenceEndDate = $('event-end-date').value;

      if (!title) return showFormStatus('Please enter an event title.', 'error');
      if (!date) return showFormStatus('Please enter a date.', 'error');

      $('create-btn').disabled = true;
      $('create-btn').textContent = 'Creating event...';

      try {
        const res = await fetch('/api/events/create', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, date, startTime, endTime, location, description, recurrenceType, recurrenceDays, recurrenceEndDate })
        });
        const data = await res.json();

        if (data.success) {
          showFormStatus(`Event created! <a href="${data.htmlLink}" target="_blank">View in Google Calendar</a>`, 'success');
        } else {
          showFormStatus(data.error || 'Failed to create event.', 'error');
        }
      } catch (err) {
        showFormStatus('Network error: ' + err.message, 'error');
      } finally {
        $('create-btn').disabled = false;
        $('create-btn').textContent = 'Add to Google Calendar';
      }
    });

    function showFormStatus(msg, type) {
      const el = $('form-status');
      el.innerHTML = msg;
      el.className = 'status-msg ' + type;
    }

    // Init
    checkAuthStatus();
  </script>
</body>
</html>
